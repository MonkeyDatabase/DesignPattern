## 问题场景

1. 小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同
2. 有客户要求以新闻的形式发布
3. 有客户要求以博客的方式发布
3. 有客户要求以公众号的方式发布

## 问题场景的问题解法

1. 直接将原网站项目工程复制一份，根据新用户的不同要求进行定制修改，在原来的代码上改
2. 改完之后，将各个客户的系统部署到各自的服务器上

## 问题场景的问题解法的问题

1. 需要的网站结构相似度很高，只是展示的外观不一样，而且各个客户的网站预计负载都不高
2. 如果各自部署服务器的话，成本也会很高
3. 如果把几个客户各自的网站，融合为一个网站，各个用户的网站共享相关的代码和数据，部署到一台服务器上，对于各种硬件资源也可以共享，可以大幅降低成本
4. 也就是使用享元模式

## 享元模式概念

1. 运用共享模式有效地支持大量细粒度的对象 
2. 常用于系统底层的开发，解决系统的性能问题。比如数据库连接池，如果不使用享元模式，每次操作数据库都需要连接数据库，而使用享元模式时，可以从数据库连接池直接取出一个已经与数据库建立长连接的连接，直接进行数据库操作，而节省了花费时间去建立连接过程
3. 享元模式能够解决重复对象的内存浪费问题，当系统中有大量相似对象，不需要总是创建新对象，可以从缓冲池里拿，这样可以降低系统内存，同时提高效率
4. 享元模式最常用的就是池技术，String常量池、数据库连接池、缓冲池等等都是享元模式的应用

## 享元模式uml

1. Flyweight是一个抽象的享元角色，它是产品的抽象部分，同时定义出对象的外部状态和内部状态
2. ConcreteFlyweight实现或继承了Flyweight，是具体的享元角色，它是具体产品类，实现了抽象对象定义的功能
3. FlyweightFactory是一个工厂，工厂里有有一个集合，如果集合中有可用实例则可以直接取，如果没有则创建一个并放入池中
4. UnsharedConcreteFlyweight实现或继承了Flyweight，是不可共享的角色，是各个产品的特色，一般不会出现在享元工厂中
5. FlyweightFactory是享元工厂类，聚合了Flyweight接口或抽象类，用于构建一个池容器，同时提供从池中获取对象的方法
6. Client是使用者

## 内部状态和外部状态

1. 享元模式提出了两个要求:细粒度和共享对象。这也就涉及到对象的信息，这些信息分为两个部分:内部状态和外部状态
2. 内部状态指对象共享出来的信息，存储在享元对象内部且不会随着环境改变而改变
3. 外部状态指对象得以依赖的一个标记，是随着环境改变而改变的、不可共享的状态
4. 简单来说，能共享的叫内部状态，不能共享的是外部状态

## 享元模式在该问题的应用

> 代码见/website,工厂类按照Website可以被不互斥访问的方式编码的，启动类代码中写了两段，第一段为单线程程序，第二段为多线程程序，用于证明线程安全
> 当Website池中的对象需要互斥访问时，还需要额外写占用状态相关的代码

1. Website抽象类相当于Flyweight
2. ConcreteWebsite相当于ConcreteFlyweight，即具体享元角色
3. WebsiteFactory相当于FlyWeightFactory，即享元工厂
4. 由于这三个客户的网站有很大关联，所以是可以共享大部分代码的，即有大量内部状态的，外部状态可以通过修改use方法可以达到目标，所以本例中没有UnsharedConcreteFlyweight角色
5. 由于缺乏UnsharedConcreteFlyweight，本例并不是一个好例子

## 享元模式在jdk中的应用

> 本例分析在Integer中的应用