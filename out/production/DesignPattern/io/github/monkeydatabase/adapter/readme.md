## 需求

1. 去其他国家旅游，不同国家的插座标准是不一样的
2. 插座和插头有国标、美标、欧标、南非标
3. 如果不使用转换器，插头无法插入插座
4. 如港版的Switch无法直接插到国标的插座充电，需要购买一个转换器

## 适配器模式

1. 适配器模式是结构型模式
2. 适配器模式将某个类的接口转换成客户需要的另一个接口，可以可以使之前因为接口不兼容而无法一起工作的类可以一起工作。
3. 适配器模式分为三类
   * 类适配器模式
   * 对象适配器模式
   * 接口适配器模式
4. 工作原理
   * 从用户角度看不到被适配者，解耦
   * 用户调用适配器的相关方法，适配器再调用被适配者的相关接口方法
   * 用户接收到的反馈结果就像和目标接口直接交互

## 类适配器实现原理

1. Adapter继承Source类拿到Source中的内容，实现Target接口来提供所需的功能
2. Client接收一个Target接口对象，调用接口对象的所需方法

## 接口适配器模式原理

1. 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口的每一个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类中的某些方法实现需求
2. 使用匿名内部类的方式进行使用，即**Adapter adapter=new Adapter(){};**，之所以相对于平时新建对象多了一对花括号，这是因为抽象类无法直接实例化，需要新建一个类继承该抽象类并实现全部的抽象方法，花括号就是实际继承该类的子类的类体，所以在花括号内可以重写父类方法。所以我们需要在这对花括号里重写出我们真正想用的接口中的方法。
3. 这样的话，在Client中调用接口方法时，除了真正要用的方法，其他方法全部都是空实现。

## 优缺点

* 类适配器模式
   * Java为单继承机制，所以Adapter需要继承Source类算一个缺点，这导致Target一定是一个接口，否则无法将两者关联到一个适配器上
   * 由于继承了Source类，所以Adapter类中可以重写Source类中的方法，使得Adapter的灵活性和适用性变得更强。
* 对象适配器模式\[最常使用\]
   * 为了解决单继承问题，Adapter与Source的关系不再是继承，而是与Source是聚合关系
* 接口适配器模式\[缺省适配器模式\]
   * Client在调用接口对象时，除了自己真正要用的方法被写了，其他的方法都是空实现，但是在编码时这些空方法都是可见的。
