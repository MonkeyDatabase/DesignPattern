## 需求

1. 需要完成盖房子的任务
2. 盖房子需要打桩、砌墙、封顶等流程
3. 房子有不同的图纸，比如商品房、高楼大厦、普通平房，它们虽然大致过程一致，但是具体施工工艺却有差别。

## 问题

> 代码见/buildhouses/beforedesign

1. 设置一个抽象类抽象房子，各种样式的房子继承自抽象房子，每种房子内部集成了盖房的三个工序和一个总建造方法。
2. 假如房子还有其他使用方法，那这些使用方法将和建造方法在一个类中，一个房子的建造方法只用调用一次，而使用方法将调用多次，违反了单一职责原则。
3. 实际生活中，我们并不是施工工人，无需关系房子是怎么造的，只需要如何入住和使用即可。
4. 且在不使用建造者模式的代码中，各个工序方法也是public的，因为它们要继承在抽象房子类，private方法无法被继承和重写。
5. 所以要使用建造者模式。

## 创造者模式

> 代码见/buildhouses/improve

1. 建造者模式是一种构建模式。
2. 建造者模式将复杂对象的构建过程与表示进行分离，从而通过相同的构建过程创建出不同的表示。
3. 建造者模式允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户不需要知道内部具体的构建细节。

## 角色

* Product:一个具体的产品对象
* Builder:创建一个Product对象的各个部件指定的接口/抽象类
* ConcreteBuilder:实现接口，构建和装配各个组件
* Director:构建一个使用Builder接口的对象，它主要用于构建一个复杂的对象，它主要由两个作用
   * **隔离**了客户和对象的生产过程
   * 负责**控制**产品对象的生产过程
   
## uml

* Builder 组合了 Product : Builder■——Product
* ConcreteBuilder 继承了 Builder
* Director 聚合了 Builder : Director□——Builder


## 建造者模式 vs 抽象工厂模式

* 抽象工厂模式是由于产品有不同的维度和分类，产品家族中有一系列的产品，用户只需对应的工厂获取对应的产品，而无需关系具体的构建过程
* 建造者模式是对于构建复杂对象，用户需要指定所需产品的蓝图，由指挥者指挥建造者完成建造和组装后产生新的产品。

## 注意事项

1. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者来实现这种变化，导致系统变得很庞大，此种情况下是否选择建造者模式
2. 建造者模式所创建的产品一般有较多共同点，其组成部分类似，如果产品差异很大，则不适合使用建造者模式，此种情况下是否选择建造者模式
3. 增加新的具体建造者无需修改原有类库的代码。只会这类针对抽象建造者编程，系统扩展方便，符合开闭原则。